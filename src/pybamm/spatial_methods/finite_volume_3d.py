import pybamm
import numpy as np
from scipy.sparse import csr_matrix, diags, vstack
from pybamm.spatial_methods.spatial_method import SpatialMethod


class FiniteVolume3D(SpatialMethod):
    """
    A class which implements the finite volume method for 3D tetrahedral meshes.

    This class extends the standard FiniteVolume class to work with unstructured
    3D tetrahedral meshes generated by PyGmsh.

    Parameters
    ----------
    options : dict-like, optional
        A dictionary of options to be passed to the spatial method.
    """

    def __init__(self, options=None):
        super().__init__(options)

    def build(self, mesh):
        super().build(mesh)
        # add npts_for_broadcast to mesh domains for this particular discretisation
        for dom in mesh.keys():
            mesh[dom].npts_for_broadcast_to_nodes = mesh[dom].npts

    def spatial_variable(self, symbol):
        """
        Creates a discretised spatial variable compatible with
        the FiniteVolume3D method.

        Parameters
        ----------
        symbol : :class:`pybamm.SpatialVariable`
            The spatial variable to be discretised.

        Returns
        -------
        :class:`pybamm.Vector`
            Contains the discretised spatial variable
        """
        symbol_mesh = self.mesh[symbol.domain]

        # For 3D meshes, return the appropriate coordinate
        if isinstance(symbol_mesh, pybamm.SubMesh3D):
            if symbol.name == "x":
                entries = symbol_mesh.nodes[:, 0]
            elif symbol.name == "y":
                entries = symbol_mesh.nodes[:, 1]
            elif symbol.name == "z":
                entries = symbol_mesh.nodes[:, 2]
            else:
                raise ValueError(f"Unrecognized spatial variable {symbol.name}")

            return pybamm.Vector(entries, domains=symbol.domains)
        else:
            # Fall back to standard implementation for non-3D meshes
            return super().spatial_variable(symbol)

    def gradient(self, symbol, discretised_symbol, boundary_conditions):
        """
        Calculates the gradient of a symbol using the finite volume method on a
        3D tetrahedral mesh.

        Parameters
        ----------
        symbol : :class:`pybamm.Symbol`
            The symbol whose gradient is to be calculated
        discretised_symbol : :class:`pybamm.Symbol`
            The discretised symbol
        boundary_conditions : dict
            The boundary conditions for the symbol

        Returns
        -------
        :class:`pybamm.Symbol`
            The discretised gradient
        """
        domain = symbol.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().gradient(symbol, discretised_symbol, boundary_conditions)

        # Add Dirichlet boundary conditions, if defined
        if symbol in boundary_conditions:
            bcs = boundary_conditions[symbol]
            if any(bc[1] == "Dirichlet" for bc in bcs.values()):
                # add ghost nodes and update domain
                discretised_symbol, domain = self.add_ghost_nodes_3d(
                    symbol, discretised_symbol, bcs
                )

        # Calculate gradient using 3D gradient matrix
        gradient_matrix = self.gradient_matrix_3d(domain, symbol.domains)

        # Multiply by gradient matrix
        out = gradient_matrix @ discretised_symbol

        # Add Neumann boundary conditions, if defined
        if symbol in boundary_conditions:
            bcs = boundary_conditions[symbol]
            if any(bc[1] == "Neumann" for bc in bcs.values()):
                out = self.add_neumann_values_3d(symbol, out, bcs, domain)

            # Add Robin boundary conditions, if defined
            if any(bc[1] == "Robin" for bc in bcs.values()):
                out = self.add_robin_values_3d(symbol, out, bcs, domain)

        return out

    def gradient_matrix_3d(self, domain, domains):
        """
        Gradient matrix for finite volumes on a 3D tetrahedral mesh.

        Parameters
        ----------
        domain : list
            The domain in which to compute the gradient matrix
        domains : dict
            The domains of the symbol

        Returns
        -------
        :class:`pybamm.Matrix`
            The finite volume gradient matrix for the domain
        """
        submesh = self.mesh[domain]

        # For 3D tetrahedral mesh, we need to compute gradients differently
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().gradient_matrix(domain, domains)

        # Get the nodes and tetrahedra
        points = submesh.points
        tets = submesh.tetrahedra
        n_nodes = len(points)
        n_tets = len(tets)

        # Initialize gradient matrices for each component (x, y, z)
        rows, cols, data_x, data_y, data_z = [], [], [], [], []

        # For each tetrahedron, compute the gradient
        for i, tet in enumerate(tets):
            # Get the vertices of the tetrahedron
            p = points[tet]

            # Compute the volume of the tetrahedron
            # v1 = p[1] - p[0]
            # v2 = p[2] - p[0]
            # v3 = p[3] - p[0]
            # vol = np.abs(np.dot(v1, np.cross(v2, v3))) / 6

            # Compute the gradients using shape functions
            # For a tetrahedron, we can compute the gradient directly
            # using the finite element shape function derivatives

            # Set up the linear system to solve for the gradient coefficients
            A = np.vstack([np.ones(4), p[:, 0], p[:, 1], p[:, 2]]).T

            # Compute the inverse of A
            try:
                Ainv = np.linalg.inv(A)
            except np.linalg.LinAlgError:
                # If the tetrahedron is degenerate, skip it
                continue

            # The gradient coefficients are in the rows of Ainv (excluding the first row)
            grad_coeffs = Ainv[1:, :]

            # Add entries to the gradient matrices
            for j, vertex in enumerate(tet):
                rows.append(i)
                cols.append(vertex)
                data_x.append(grad_coeffs[0, j])
                data_y.append(grad_coeffs[1, j])
                data_z.append(grad_coeffs[2, j])

        # Create sparse matrices for each component
        grad_x = csr_matrix((data_x, (rows, cols)), shape=(n_tets, n_nodes))
        grad_y = csr_matrix((data_y, (rows, cols)), shape=(n_tets, n_nodes))
        grad_z = csr_matrix((data_z, (rows, cols)), shape=(n_tets, n_nodes))

        # Combine the gradient matrices into a block matrix
        # [grad_x]
        # [grad_y]
        # [grad_z]
        gradient_matrix = vstack([grad_x, grad_y, grad_z])

        return pybamm.Matrix(gradient_matrix)

    def divergence(self, symbol, discretised_symbol, boundary_conditions):
        """
        Calculates the divergence of a symbol using the finite volume method on a
        3D tetrahedral mesh.

        Parameters
        ----------
        symbol : :class:`pybamm.Symbol`
            The symbol whose divergence is to be calculated
        discretised_symbol : :class:`pybamm.Symbol`
            The discretised symbol
        boundary_conditions : dict
            The boundary conditions for the symbol

        Returns
        -------
        :class:`pybamm.Symbol`
            The discretised divergence
        """
        domain = symbol.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().divergence(symbol, discretised_symbol, boundary_conditions)

        # Calculate divergence using 3D divergence matrix
        divergence_matrix = self.divergence_matrix_3d(symbol.domains)

        # Multiply by divergence matrix
        out = divergence_matrix @ discretised_symbol

        return out

    def divergence_matrix_3d(self, domains):
        """
        Divergence matrix for finite volumes on a 3D tetrahedral mesh.

        Parameters
        ----------
        domains : dict
            The domains of the symbol

        Returns
        -------
        :class:`pybamm.Matrix`
            The finite volume divergence matrix for the domain
        """
        submesh = self.mesh[domains["primary"]]

        # For 3D tetrahedral mesh, we need to compute divergence differently
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().divergence_matrix(domains)

        # Get the nodes and tetrahedra
        points = submesh.points
        tets = submesh.tetrahedra
        n_nodes = len(points)
        n_tets = len(tets)

        # For a vector field [Fx, Fy, Fz], the divergence is computed by
        # taking the dot product of the gradient operator with the vector field

        # Initialize the divergence matrix
        rows, cols, data = [], [], []

        # For each node, compute the contribution from each adjacent tetrahedron
        for i, adjacency in enumerate(submesh.adjacency_list):
            # Get the volumes of the adjacent tetrahedra
            vols = submesh.volumes[adjacency]

            # Add contribution from each adjacent tetrahedron
            for j, tet_idx in enumerate(adjacency):
                # Add entries for x, y, and z components
                rows.extend([i, i, i])
                cols.extend([tet_idx, tet_idx + n_tets, tet_idx + 2 * n_tets])

                # The coefficient is the volume of the tetrahedron divided by the
                # number of vertices (4 for a tetrahedron)
                coef = vols[j] / 4
                data.extend([coef, coef, coef])

        # Create the divergence matrix
        divergence_matrix = csr_matrix(
            (data, (rows, cols)), shape=(n_nodes, 3 * n_tets)
        )

        return pybamm.Matrix(divergence_matrix)

    def laplacian(self, symbol, discretised_symbol, boundary_conditions):
        """
        Calculates the laplacian of a symbol using the finite volume method on a
        3D tetrahedral mesh.

        Parameters
        ----------
        symbol : :class:`pybamm.Symbol`
            The symbol whose laplacian is to be calculated
        discretised_symbol : :class:`pybamm.Symbol`
            The discretised symbol
        boundary_conditions : dict
            The boundary conditions for the symbol

        Returns
        -------
        :class:`pybamm.Symbol`
            The discretised laplacian
        """
        domain = symbol.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().laplacian(symbol, discretised_symbol, boundary_conditions)

        # Get the initial Laplacian matrix for 3D tetrahedral mesh
        laplacian_matrix = self.laplacian_matrix_3d(domain, symbol.domains)

        # Apply boundary conditions if provided
        if symbol in boundary_conditions:
            bcs = boundary_conditions[symbol]
            modified_matrix = laplacian_matrix.copy()
            correction_vector = np.zeros(len(submesh.points))

            # Handle different types of boundary conditions
            for side, (bc_value, bc_type) in bcs.items():
                # Get nodes on this boundary
                boundary_nodes = self._get_boundary_nodes(submesh, side)

                if bc_type == "Dirichlet":
                    # For Dirichlet BC, modify the matrix to enforce u = bc_value at boundary
                    for node_idx in boundary_nodes:
                        # Get the row in the Laplacian matrix corresponding to this node
                        row = modified_matrix.matrix.getrow(node_idx)

                        # Set all coefficients to zero except diagonal
                        for i, _j in zip(row.indices, range(len(row.indices))):
                            if i != node_idx:
                                modified_matrix.matrix[node_idx, i] = 0

                        # Set diagonal to 1 for identity operation
                        modified_matrix.matrix[node_idx, node_idx] = 1

                        # Add value to correction vector
                        bc_value_float = (
                            bc_value.evaluate()
                            if hasattr(bc_value, "evaluate")
                            else bc_value
                        )
                        correction_vector[node_idx] = bc_value_float

                elif bc_type == "Neumann":
                    # For Neumann BC, modify the matrix to enforce du/dn = bc_value at boundary
                    for node_idx in boundary_nodes:
                        # Get the neighbors of this node (nodes connected by an edge)
                        neighbors = []
                        for tet in submesh.tetrahedra:
                            if node_idx in tet:
                                for vertex in tet:
                                    if vertex != node_idx and vertex not in neighbors:
                                        neighbors.append(vertex)

                        # Find the neighbors inside the domain (not on this boundary)
                        interior_neighbors = [
                            n for n in neighbors if n not in boundary_nodes
                        ]

                        # Get the normal direction for this boundary
                        if side == "left":
                            normal = np.array([-1, 0, 0])
                        elif side == "right":
                            normal = np.array([1, 0, 0])
                        elif side == "front":
                            normal = np.array([0, -1, 0])
                        elif side == "back":
                            normal = np.array([0, 1, 0])
                        elif side == "bottom":
                            normal = np.array([0, 0, -1])
                        elif side == "top":
                            normal = np.array([0, 0, 1])

                        # Modify the coefficients for this node to enforce the Neumann condition
                        if interior_neighbors:
                            # Compute the direction vectors to interior neighbors
                            direction_vectors = []
                            for n in interior_neighbors:
                                vec = submesh.points[n] - submesh.points[node_idx]
                                direction_vectors.append(vec / np.linalg.norm(vec))

                            # Find the interior neighbor most aligned with the normal direction
                            best_neighbor = None
                            best_alignment = -1
                            for n, vec in zip(interior_neighbors, direction_vectors):
                                alignment = np.abs(np.dot(vec, normal))
                                if alignment > best_alignment:
                                    best_alignment = alignment
                                    best_neighbor = n

                            if best_neighbor is not None:
                                # Get the distance between nodes
                                dist = np.linalg.norm(
                                    submesh.points[best_neighbor]
                                    - submesh.points[node_idx]
                                )

                                # Compute the derivative approximation coefficients
                                node_coef = -1 / dist
                                neighbor_coef = 1 / dist

                                # Update the Laplacian matrix to enforce du/dn = bc_value
                                modified_matrix.matrix[node_idx, node_idx] = node_coef
                                modified_matrix.matrix[node_idx, best_neighbor] = (
                                    neighbor_coef
                                )

                                # Add the boundary value to the correction vector
                                bc_value_float = (
                                    bc_value.evaluate()
                                    if hasattr(bc_value, "evaluate")
                                    else bc_value
                                )
                                correction_vector[node_idx] = bc_value_float

                elif bc_type == "Robin":
                    # Robin boundary condition: a*u + b*du/dn = c
                    # This is a simplified implementation that treats Robin BCs as a weighted
                    # combination of Dirichlet and Neumann
                    for node_idx in boundary_nodes:
                        # Get the Robin BC parameters (a, b, c)
                        a, b, c = bc_value
                        if hasattr(a, "evaluate"):
                            a = a.evaluate()
                        if hasattr(b, "evaluate"):
                            b = b.evaluate()
                        if hasattr(c, "evaluate"):
                            c = c.evaluate()

                        # Get the neighbors of this node
                        neighbors = []
                        for tet in submesh.tetrahedra:
                            if node_idx in tet:
                                for vertex in tet:
                                    if vertex != node_idx and vertex not in neighbors:
                                        neighbors.append(vertex)

                        # Find interior neighbors
                        interior_neighbors = [
                            n for n in neighbors if n not in boundary_nodes
                        ]

                        if interior_neighbors:
                            # Choose the first interior neighbor for simplicity
                            neighbor = interior_neighbors[0]

                            # Get the distance between nodes
                            dist = np.linalg.norm(
                                submesh.points[neighbor] - submesh.points[node_idx]
                            )

                            # Compute the coefficients for Robin condition
                            diagonal_coef = a - b / dist
                            neighbor_coef = b / dist

                            # Update the Laplacian matrix
                            modified_matrix.matrix[node_idx, node_idx] = diagonal_coef
                            modified_matrix.matrix[node_idx, neighbor] = neighbor_coef

                            # Add to correction vector
                            correction_vector[node_idx] = c

            # Create a new matrix and vector for the boundary conditions
            laplacian_matrix = modified_matrix
            boundary_correction = pybamm.Vector(correction_vector)

            # Apply the modified Laplacian matrix
            out = laplacian_matrix @ discretised_symbol + boundary_correction
        else:
            # No boundary conditions, just apply the standard Laplacian matrix
            out = laplacian_matrix @ discretised_symbol

        return out

    def laplacian_matrix_3d(self, domain, domains):
        """
        Laplacian matrix for finite volumes on a 3D tetrahedral mesh.

        Parameters
        ----------
        domain : list
            The domain in which to compute the laplacian matrix
        domains : dict
            The domains of the symbol

        Returns
        -------
        :class:`pybamm.Matrix`
            The finite volume laplacian matrix for the domain
        """
        submesh = self.mesh[domain]

        # For 3D tetrahedral mesh, we need to compute the Laplacian differently
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().laplacian_matrix(domain, domains)

        # Get the nodes and tetrahedra
        points = submesh.points
        tets = submesh.tetrahedra
        n_nodes = len(points)

        # Initialize the Laplacian matrix
        rows, cols, data = [], [], []

        # For each node, compute the contribution from each adjacent node
        for i, adjacency in enumerate(submesh.adjacency_list):
            # Get the adjacent nodes
            adj_nodes = []
            for tet_idx in adjacency:
                tet = tets[tet_idx]
                for node in tet:
                    if node != i and node not in adj_nodes:
                        adj_nodes.append(node)

            # Compute the total weight for the diagonal entry
            diag_weight = 0

            # Add off-diagonal entries
            for j in adj_nodes:
                # Compute the weight for this edge
                # For a uniform mesh, this would be 1/h^2 where h is the edge length
                # For a non-uniform mesh, we use a more general formula

                # Find the tetrahedra that contain both nodes i and j
                common_tets = []
                for tet_idx in adjacency:
                    tet = tets[tet_idx]
                    if i in tet and j in tet:
                        common_tets.append(tet_idx)

                # Compute the weight as the sum of contributions from each common tetrahedron
                weight = 0
                for tet_idx in common_tets:
                    # Get the volume of the tetrahedron
                    vol = submesh.volumes[tet_idx]

                    # Compute the distance between nodes i and j
                    dist = np.linalg.norm(points[i] - points[j])

                    # Add contribution to the weight
                    # The factor 1/6 comes from the finite element formulation
                    weight += vol / (6 * dist**2)

                # Add the entry to the matrix
                rows.append(i)
                cols.append(j)
                data.append(-weight)

                # Add to the diagonal weight
                diag_weight += weight

            # Add the diagonal entry
            rows.append(i)
            cols.append(i)
            data.append(diag_weight)

        # Create the Laplacian matrix
        laplacian_matrix = csr_matrix((data, (rows, cols)), shape=(n_nodes, n_nodes))

        return pybamm.Matrix(laplacian_matrix)

    def mass_matrix(self, symbol, boundary_conditions):
        """
        Mass matrix for finite volumes on a 3D tetrahedral mesh.

        Parameters
        ----------
        symbol : :class:`pybamm.Symbol`
            The symbol for which to compute the mass matrix
        boundary_conditions : dict
            The boundary conditions for the symbol

        Returns
        -------
        :class:`pybamm.Matrix`
            The finite volume mass matrix for the domain
        """
        domain = symbol.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().mass_matrix(symbol, boundary_conditions)

        # For a finite volume method, the mass matrix is diagonal
        # with the control volumes on the diagonal
        n_nodes = len(submesh.points)

        # Compute the control volumes for each node
        control_volumes = np.zeros(n_nodes)

        # For each tetrahedron, distribute its volume to its vertices
        for i, tet in enumerate(submesh.tetrahedra):
            # Get the volume of the tetrahedron
            vol = submesh.volumes[i]

            # Distribute the volume equally to the four vertices
            for vertex in tet:
                control_volumes[vertex] += vol / 4

        # Create the mass matrix
        mass_matrix = diags(control_volumes, format="csr")

        return pybamm.Matrix(mass_matrix)

    def _find_interior_neighbors(self, submesh, node_idx, boundary_nodes):
        """
        Find the interior neighbors of a boundary node.

        Parameters
        ----------
        submesh : :class:`pybamm.SubMesh3D`
            The submesh
        node_idx : int
            The index of the boundary node
        boundary_nodes : list
            The list of all boundary nodes

        Returns
        -------
        list
            The indices of interior neighbors
        """
        # Find all neighbors of the node
        neighbors = []
        for tet in submesh.tetrahedra:
            if node_idx in tet:
                for vertex in tet:
                    if vertex != node_idx and vertex not in neighbors:
                        neighbors.append(vertex)

        # Filter out boundary nodes to get interior neighbors
        interior_neighbors = [n for n in neighbors if n not in boundary_nodes]

        return interior_neighbors

    def _get_normal_vector(self, side):
        """
        Get the normal vector for a boundary face.

        Parameters
        ----------
        side : str
            The boundary face ("left", "right", "front", "back", "top", "bottom")

        Returns
        -------
        numpy.ndarray
            The normal vector pointing outward from the domain
        """
        if side == "left":
            return np.array([-1, 0, 0])
        elif side == "right":
            return np.array([1, 0, 0])
        elif side == "front":
            return np.array([0, -1, 0])
        elif side == "back":
            return np.array([0, 1, 0])
        elif side == "bottom":
            return np.array([0, 0, -1])
        elif side == "top":
            return np.array([0, 0, 1])
        else:
            raise ValueError(f"Unknown boundary face: {side}")

    def boundary_value_or_flux(self, symbol, discretised_child, bcs=None):
        domain = discretised_child.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().boundary_value_or_flux(symbol, discretised_child, bcs)

        # For 3D tetrahedral mesh, we need to handle boundary values differently
        if isinstance(symbol, pybamm.BoundaryValue):
            # Get the boundary face
            face = symbol.side

            # Find the nodes on the boundary face
            boundary_nodes = self._get_boundary_nodes(submesh, face)

            # Create a matrix to extract the values at the boundary nodes
            n_nodes = len(submesh.points)
            n_boundary = len(boundary_nodes)

            rows = np.arange(n_boundary)
            cols = boundary_nodes
            data = np.ones(n_boundary)

            matrix = csr_matrix((data, (rows, cols)), shape=(n_boundary, n_nodes))

            # Extract the boundary values
            boundary_value = pybamm.Matrix(matrix) @ discretised_child

            # Average the boundary values
            if n_boundary > 0:
                boundary_value = pybamm.Sum(boundary_value) / n_boundary
            else:
                boundary_value = pybamm.Scalar(0)

            return boundary_value

        elif isinstance(symbol, pybamm.BoundaryGradient):
            # Get the boundary face
            face = symbol.side

            # Find the nodes on the boundary face
            boundary_nodes = self._get_boundary_nodes(submesh, face)
            n_boundary = len(boundary_nodes)

            if n_boundary == 0:
                return pybamm.Scalar(0)

            # Get the normal vector for this face
            normal = self._get_normal_vector(face)

            # Create arrays to store the gradient values
            gradients = np.zeros(n_boundary)

            # For each boundary node, compute the gradient in the normal direction
            for i, node_idx in enumerate(boundary_nodes):
                # Find interior neighbors
                interior_neighbors = self._find_interior_neighbors(
                    submesh, node_idx, boundary_nodes
                )

                if interior_neighbors:
                    # Choose the interior neighbor closest to the normal direction
                    best_neighbor = None
                    best_alignment = -1

                    for neighbor in interior_neighbors:
                        # Direction from boundary node to interior node
                        direction = submesh.points[neighbor] - submesh.points[node_idx]
                        direction_unit = direction / np.linalg.norm(direction)

                        # Check alignment with normal vector
                        alignment = np.abs(np.dot(direction_unit, normal))
                        if alignment > best_alignment:
                            best_alignment = alignment
                            best_neighbor = neighbor

                    if best_neighbor is not None:
                        # Compute distance
                        distance = np.linalg.norm(
                            submesh.points[best_neighbor] - submesh.points[node_idx]
                        )

                        # Extract values
                        u_boundary = discretised_child.entries[node_idx]
                        u_interior = discretised_child.entries[best_neighbor]

                        # Compute gradient using finite difference
                        gradients[i] = (u_interior - u_boundary) / distance

            # Return the boundary gradients
            return pybamm.Vector(gradients)

        else:
            raise ValueError(f"Unknown boundary symbol type: {type(symbol)}")

    def _get_boundary_nodes(self, submesh, face):
        """
        Find the nodes on a boundary face of a 3D tetrahedral mesh.

        Parameters
        ----------
        submesh : :class:`pybamm.SubMesh3D`
            The submesh
        face : str
            The boundary face ("left", "right", "front", "back", "top", "bottom")

        Returns
        -------
        list
            The indices of the nodes on the boundary face
        """
        points = submesh.points

        # Define the boundary faces
        if face == "left":
            # x = min
            x_min = np.min(points[:, 0])
            boundary_nodes = np.where(np.isclose(points[:, 0], x_min))[0]
        elif face == "right":
            # x = max
            x_max = np.max(points[:, 0])
            boundary_nodes = np.where(np.isclose(points[:, 0], x_max))[0]
        elif face == "front":
            # y = min
            y_min = np.min(points[:, 1])
            boundary_nodes = np.where(np.isclose(points[:, 1], y_min))[0]
        elif face == "back":
            # y = max
            y_max = np.max(points[:, 1])
            boundary_nodes = np.where(np.isclose(points[:, 1], y_max))[0]
        elif face == "bottom":
            # z = min
            z_min = np.min(points[:, 2])
            boundary_nodes = np.where(np.isclose(points[:, 2], z_min))[0]
        elif face == "top":
            # z = max
            z_max = np.max(points[:, 2])
            boundary_nodes = np.where(np.isclose(points[:, 2], z_max))[0]
        else:
            raise ValueError(f"Unknown boundary face: {face}")

        return boundary_nodes

    def _calculate_local_normal(self, submesh, tet_idx, boundary_nodes):
        """
        Calculate the local normal vector for a boundary tetrahedron.

        Parameters
        ----------
        submesh : :class:`pybamm.SubMesh3D`
            The submesh
        tet_idx : int
            The index of the tetrahedron
        boundary_nodes : list
            The list of boundary nodes

        Returns
        -------
        numpy.ndarray
            The local normal vector
        """
        # Get the tetrahedron
        tet = submesh.tetrahedra[tet_idx]

        # Find boundary nodes in this tetrahedron
        tet_boundary_nodes = [node for node in tet if node in boundary_nodes]

        if len(tet_boundary_nodes) >= 3:
            # We have at least three boundary nodes, which form a face
            p1 = submesh.points[tet_boundary_nodes[0]]
            p2 = submesh.points[tet_boundary_nodes[1]]
            p3 = submesh.points[tet_boundary_nodes[2]]

            # Calculate vectors along the face
            v1 = p2 - p1
            v2 = p3 - p1

            # Calculate normal vector using cross product
            normal = np.cross(v1, v2)

            # Normalize
            norm = np.linalg.norm(normal)
            if norm > 0:
                normal = normal / norm

            # Check if the normal points outward
            # To do this, we find a non-boundary node in the tetrahedron
            interior_nodes = [node for node in tet if node not in boundary_nodes]

            if interior_nodes:
                # Calculate vector from boundary point to interior point
                interior_vec = submesh.points[interior_nodes[0]] - p1

                # If normal points inward, flip it
                if np.dot(normal, interior_vec) > 0:
                    normal = -normal

            return normal
        else:
            # Not enough boundary nodes to calculate a local normal
            # Fall back to global normal based on boundary side

            # First, try to determine which boundary face this is on
            boundary_sides = ["left", "right", "front", "back", "top", "bottom"]
            for side in boundary_sides:
                side_nodes = self._get_boundary_nodes(submesh, side)
                if all(node in side_nodes for node in tet_boundary_nodes):
                    return self._get_normal_vector(side)

            # If we can't determine the side, use an average of global normals
            return np.array([0, 0, 0])  # Default

    def add_ghost_nodes_3d(self, symbol, discretised_symbol, bcs):
        domain = symbol.domain
        submesh = self.mesh[domain]

        # Get the number of nodes
        n_nodes = len(submesh.points)

        # Initialize the list of ghost nodes to add
        ghost_nodes = []

        # Process each boundary condition
        for side, (bc_value, bc_type) in bcs.items():
            if bc_type == "Dirichlet":
                # Find the nodes on this boundary
                boundary_nodes = self._get_boundary_nodes(submesh, side)

                if len(boundary_nodes) > 0:
                    # For each boundary node, create a ghost node
                    for node_idx in boundary_nodes:
                        # Get the node position
                        node_pos = submesh.points[node_idx]

                        # Find the normal direction for this boundary
                        normal = self._get_normal_vector(side)

                        # Create a ghost node position by reflecting across the boundary
                        # For simplicity, we'll use a fixed distance for the ghost node
                        ghost_pos = (
                            node_pos - 2 * normal * 0.01
                        )  # 0.01 is an arbitrary small distance

                        # Add the ghost node to the list
                        ghost_nodes.append((node_idx, ghost_pos, bc_value))

            elif bc_type == "Robin":
                # Robin boundary condition: a*u + b*du/dn = c
                boundary_nodes = self._get_boundary_nodes(submesh, side)

                if len(boundary_nodes) > 0:
                    for node_idx in boundary_nodes:
                        # Get the node position
                        node_pos = submesh.points[node_idx]

                        # Get the normal direction for this boundary
                        normal = self._get_normal_vector(side)

                        # Get the Robin parameters (a, b, c)
                        a, b, c = bc_value
                        a_val = a.evaluate() if hasattr(a, "evaluate") else a
                        b_val = b.evaluate() if hasattr(b, "evaluate") else b
                        c_val = c.evaluate() if hasattr(c, "evaluate") else c

                        # Distance to ghost node
                        h = 0.01  # arbitrary distance

                        # For Robin BC, we set the ghost value so that
                        # a*u + b*(u_ghost - u)/(2*h) = c
                        # This gives u_ghost = u + 2*h*(c - a*u)/b
                        # We'll store the coefficient and the value separately
                        ghost_nodes.append(
                            (
                                node_idx,
                                node_pos - 2 * normal * h,
                                (
                                    lambda u,
                                    h=h,
                                    c_val=c_val,
                                    a_val=a_val,
                                    b_val=b_val: u + 2 * h * (c_val - a_val * u) / b_val
                                ),
                            )
                        )

        # If there are no ghost nodes to add, return the original symbol
        if not ghost_nodes:
            return discretised_symbol, domain

        # Create a matrix to add the ghost nodes
        rows, cols, data = [], [], []

        # Add entries for the original nodes
        for i in range(n_nodes):
            rows.append(i)
            cols.append(i)
            data.append(1.0)

        # Add entries for the ghost nodes
        for i, (node_idx, _, bc_value) in enumerate(ghost_nodes):
            # For each ghost node, we set its value based on the boundary condition
            rows.append(n_nodes + i)
            cols.append(node_idx)

            if callable(bc_value):
                # Handle Robin BC - this requires an iterative approach
                # For now, we'll store a placeholder and fix it later
                data.append(-1.0)  # Will be updated after solving
            else:
                # For Dirichlet, we set ghost value to 2*bc_value - node_value
                data.append(-1.0)

        # Create the matrix
        n_ghost = len(ghost_nodes)
        matrix = csr_matrix((data, (rows, cols)), shape=(n_nodes + n_ghost, n_nodes))

        # Create a vector for the boundary values
        bc_vector = np.zeros(n_nodes + n_ghost)
        for i, (_, _, bc_value) in enumerate(ghost_nodes):
            if not callable(bc_value):
                bc_vector[n_nodes + i] = (
                    2 * bc_value.evaluate()
                    if hasattr(bc_value, "evaluate")
                    else 2 * bc_value
                )

        # Update the domain to include ghost nodes
        new_domain = domain.copy()
        for side in bcs:
            if bcs[side][1] in ["Dirichlet", "Robin"]:
                new_domain.append(f"{domain[0]}_{side} ghost cells")

        # Apply the matrix and add the boundary values
        new_symbol = pybamm.Matrix(matrix) @ discretised_symbol + pybamm.Vector(
            bc_vector
        )

        return new_symbol, new_domain

    def add_neumann_values_3d(self, symbol, discretised_gradient, bcs, domain):
        """
        Add Neumann values to a gradient for a 3D tetrahedral mesh.

        Parameters
        ----------
        symbol : :class:`pybamm.Symbol`
            The symbol whose gradient is being calculated
        discretised_gradient : :class:`pybamm.Symbol`
            The discretised gradient
        bcs : dict
            The boundary conditions for the symbol
        domain : list
            The domain of the gradient

        Returns
        -------
        :class:`pybamm.Symbol`
            The gradient with Neumann values added
        """
        submesh = self.mesh[domain]

        # Get the number of tetrahedra
        n_tets = len(submesh.tetrahedra)

        # Initialize the boundary value vector
        bc_vector = np.zeros(3 * n_tets)  # 3 components (x, y, z) for each tetrahedron

        # Process each boundary condition
        for side, (bc_value, bc_type) in bcs.items():
            if bc_type == "Neumann":
                # Find the nodes on this boundary
                boundary_nodes = self._get_boundary_nodes(submesh, side)

                # Find tetrahedra that have at least one node on the boundary
                boundary_tets = []
                for i, tet in enumerate(submesh.tetrahedra):
                    if any(node in boundary_nodes for node in tet):
                        boundary_tets.append(i)

                # Convert boundary value to float
                bc_value_float = (
                    bc_value.evaluate() if hasattr(bc_value, "evaluate") else bc_value
                )

                # Add the Neumann value to the boundary tetrahedra
                for tet_idx in boundary_tets:
                    # Calculate local normal based on boundary face orientation
                    local_normal = self._calculate_local_normal(
                        submesh, tet_idx, boundary_nodes
                    )

                    if np.any(local_normal):  # Check if we got a valid normal
                        # Add the Neumann value in the normal direction
                        bc_vector[tet_idx] += local_normal[0] * bc_value_float
                        bc_vector[tet_idx + n_tets] += local_normal[1] * bc_value_float
                        bc_vector[tet_idx + 2 * n_tets] += (
                            local_normal[2] * bc_value_float
                        )
                    else:
                        # Fall back to global normal
                        normal = self._get_normal_vector(side)
                        bc_vector[tet_idx] += normal[0] * bc_value_float
                        bc_vector[tet_idx + n_tets] += normal[1] * bc_value_float
                        bc_vector[tet_idx + 2 * n_tets] += normal[2] * bc_value_float

        # Add the boundary values to the gradient
        return discretised_gradient + pybamm.Vector(bc_vector)

    def add_robin_values_3d(self, symbol, discretised_gradient, bcs, domain):
        """
        Add Robin boundary condition values to a gradient for a 3D tetrahedral mesh.

        Parameters
        ----------
        symbol : :class:`pybamm.Symbol`
            The symbol whose gradient is being calculated
        discretised_gradient : :class:`pybamm.Symbol`
            The discretised gradient
        bcs : dict
            The boundary conditions for the symbol
        domain : list
            The domain of the gradient

        Returns
        -------
        :class:`pybamm.Symbol`
            The gradient with Robin values added
        """
        submesh = self.mesh[domain]

        # Get the number of tetrahedra
        n_tets = len(submesh.tetrahedra)

        # Initialize the boundary value vector
        bc_vector = np.zeros(3 * n_tets)  # 3 components (x, y, z) for each tetrahedron

        # Process each boundary condition
        for side, (bc_value, bc_type) in bcs.items():
            if bc_type == "Robin":
                # Find the nodes on this boundary
                boundary_nodes = self._get_boundary_nodes(submesh, side)

                # Find tetrahedra that have at least one node on the boundary
                boundary_tets = []
                for i, tet in enumerate(submesh.tetrahedra):
                    if any(node in boundary_nodes for node in tet):
                        boundary_tets.append(i)

                # Get the normal direction for this boundary
                normal = self._get_normal_vector(side)

                # Get the Robin parameters (a, b, c)
                a, b, c = bc_value
                a_val = a.evaluate() if hasattr(a, "evaluate") else a
                b_val = b.evaluate() if hasattr(b, "evaluate") else b
                c_val = c.evaluate() if hasattr(c, "evaluate") else c

                # For Robin BC a*u + b*du/dn = c, we need to modify the gradient
                # Add the Robin value to the boundary tetrahedra
                for tet_idx in boundary_tets:
                    # Get the nodes of this tetrahedron
                    tet_nodes = submesh.tetrahedra[tet_idx]

                    # Get the boundary nodes in this tetrahedron
                    tet_boundary_nodes = [
                        node for node in tet_nodes if node in boundary_nodes
                    ]

                    if tet_boundary_nodes:
                        # Average the u values at boundary nodes
                        u_avg = np.mean(
                            [
                                discretised_gradient.entries[node]
                                for node in tet_boundary_nodes
                            ]
                        )

                        # Compute the Robin gradient value: (c - a*u)/b
                        robin_grad = (c_val - a_val * u_avg) / b_val

                        # Add the Robin gradient in the normal direction
                        bc_vector[tet_idx] += normal[0] * robin_grad
                        bc_vector[tet_idx + n_tets] += normal[1] * robin_grad
                        bc_vector[tet_idx + 2 * n_tets] += normal[2] * robin_grad

        # Add the boundary values to the gradient
        return discretised_gradient + pybamm.Vector(bc_vector)

    def integral(self, child, discretised_child, integration_dimension):
        """
        Compute the integral of a child over a domain.

        Parameters
        ----------
        child : :class:`pybamm.Symbol`
            The symbol to integrate
        discretised_child : :class:`pybamm.Symbol`
            The discretised symbol
        integration_dimension : str
            The dimension over which to integrate

        Returns
        -------
        :class:`pybamm.Symbol`
            The integral
        """
        domain = child.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().integral(child, discretised_child, integration_dimension)

        # Compute the control volumes for each node
        n_nodes = len(submesh.points)
        control_volumes = np.zeros(n_nodes)

        # For each tetrahedron, distribute its volume to its vertices
        for i, tet in enumerate(submesh.tetrahedra):
            # Get the volume of the tetrahedron
            vol = submesh.volumes[i]

            # Distribute the volume equally to the four vertices
            for vertex in tet:
                control_volumes[vertex] += vol / 4

        # Create the integration vector
        integration_vector = pybamm.Matrix(control_volumes)

        # Compute the integral
        out = integration_vector @ discretised_child

        return out

    def definite_integral_matrix(
        self, child, vector_type="row", integration_dimension="primary"
    ):
        """
        Matrix for the definite integral in the primary dimension.

        Parameters
        ----------
        child : :class:`pybamm.Symbol`
            The symbol being integrated
        vector_type : str, optional
            Whether to return a row or column vector
        integration_dimension : str, optional
            The dimension in which to integrate

        Returns
        -------
        :class:`pybamm.Matrix`
            The integration matrix
        """
        domain = child.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().definite_integral_matrix(
                child, vector_type, integration_dimension
            )

        # For 3D tetrahedral mesh, we compute the integral as a weighted sum
        # where the weights are the control volumes

        # Compute the control volumes for each node
        n_nodes = len(submesh.points)
        control_volumes = np.zeros(n_nodes)

        # For each tetrahedron, distribute its volume to its vertices
        for i, tet in enumerate(submesh.tetrahedra):
            # Get the volume of the tetrahedron
            vol = submesh.volumes[i]

            # Distribute the volume equally to the four vertices
            for vertex in tet:
                control_volumes[vertex] += vol / 4

        # Create the integration matrix
        if vector_type == "row":
            integration_matrix = control_volumes.reshape(1, -1)
        else:  # column
            integration_matrix = control_volumes.reshape(-1, 1)

        return pybamm.Matrix(integration_matrix)

    def laplacian_3d(self, symbol, discretised_symbol, boundary_conditions=None):
        """
        Compute the Laplacian of a symbol on a 3D tetrahedral mesh.
        This is a convenience method for use in thermal models.

        Parameters
        ----------
        symbol : :class:`pybamm.Symbol`
            The symbol whose Laplacian is to be computed
        discretised_symbol : :class:`pybamm.Symbol`
            The discretised symbol
        boundary_conditions : dict, optional
            The boundary conditions for the symbol

        Returns
        -------
        :class:`pybamm.Symbol`
            The Laplacian of the symbol
        """
        if boundary_conditions is None:
            boundary_conditions = {}

        return self.laplacian(symbol, discretised_symbol, boundary_conditions)

    def indefinite_integral(self, child, discretised_child, direction):
        """
        Implementation of the indefinite integral operator for 3D meshes.

        Parameters
        ----------
        child : :class:`pybamm.Symbol`
            The symbol being integrated
        discretised_child : :class:`pybamm.Symbol`
            The discretised symbol
        direction : str
            The direction of integration

        Returns
        -------
        :class:`pybamm.Symbol`
            The indefinite integral
        """
        domain = child.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().indefinite_integral(child, discretised_child, direction)

        # For 3D tetrahedral mesh, indefinite integral is not well-defined
        # in the same way as for 1D meshes. We'll implement a simplified version
        # that integrates along one of the coordinate directions.

        # Get the points
        points = submesh.points
        n_nodes = len(points)

        # Sort nodes by the appropriate coordinate
        if direction == "x":
            coord_idx = 0
        elif direction == "y":
            coord_idx = 1
        elif direction == "z":
            coord_idx = 2
        else:
            raise ValueError(f"Unknown direction: {direction}")

        # Sort nodes by the coordinate
        sorted_indices = np.argsort(points[:, coord_idx])

        # Create a matrix to compute the indefinite integral
        rows, cols, data = [], [], []

        if direction == "forward":
            # For each node, add the values of all nodes with smaller coordinate
            for i, _idx in enumerate(sorted_indices):
                for j in range(i + 1):
                    rows.append(i)
                    cols.append(sorted_indices[j])
                    # Weight by the difference in coordinates
                    if j < i:
                        weight = (
                            points[sorted_indices[j + 1], coord_idx]
                            - points[sorted_indices[j], coord_idx]
                        )
                    else:
                        weight = 1.0
                    data.append(weight)
        else:  # backward
            # For each node, add the values of all nodes with larger coordinate
            for i, _idx in enumerate(sorted_indices):
                for j in range(i, n_nodes):
                    rows.append(i)
                    cols.append(sorted_indices[j])
                    # Weight by the difference in coordinates
                    if j > i:
                        weight = (
                            points[sorted_indices[j], coord_idx]
                            - points[sorted_indices[j - 1], coord_idx]
                        )
                    else:
                        weight = 1.0
                    data.append(weight)

        # Create the matrix
        matrix = csr_matrix((data, (rows, cols)), shape=(n_nodes, n_nodes))

        # Apply the matrix
        out = pybamm.Matrix(matrix) @ discretised_child

        return out

    def node_to_edge(self, discretised_symbol, method="arithmetic"):
        """
        Convert a discretised symbol evaluated on the cell nodes to a discretised symbol
        evaluated on the cell edges for a 3D tetrahedral mesh.

        Parameters
        ----------
        discretised_symbol : :class:`pybamm.Symbol`
            The discretised symbol evaluated on nodes
        method : str, optional
            The method to use for the conversion

        Returns
        -------
        :class:`pybamm.Symbol`
            The discretised symbol evaluated on edges
        """
        domain = discretised_symbol.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().node_to_edge(discretised_symbol, method)

        # For 3D tetrahedral mesh, we need to define what "edges" mean
        # Here, we'll use the edges of the tetrahedra

        # Get the tetrahedra
        tets = submesh.tetrahedra
        n_tets = len(tets)
        n_nodes = len(submesh.points)

        # For each tetrahedron, we have 6 edges
        # (0,1), (0,2), (0,3), (1,2), (1,3), (2,3)
        edge_pairs = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
        n_edges_per_tet = len(edge_pairs)

        # Initialize the matrix
        rows, cols, data = [], [], []

        # For each tetrahedron and each edge
        for i, tet in enumerate(tets):
            for j, (e1, e2) in enumerate(edge_pairs):
                # Get the nodes at the ends of the edge
                node1 = tet[e1]
                node2 = tet[e2]

                # Add entries for the arithmetic mean
                if method == "arithmetic":
                    rows.extend([i * n_edges_per_tet + j, i * n_edges_per_tet + j])
                    cols.extend([node1, node2])
                    data.extend([0.5, 0.5])
                elif method == "harmonic":
                    # For harmonic mean, we need to be careful about division by zero
                    # We'll use a simplified approach here
                    rows.extend([i * n_edges_per_tet + j, i * n_edges_per_tet + j])
                    cols.extend([node1, node2])
                    data.extend([0.5, 0.5])  # Simplified - should be harmonic mean

        # Create the matrix
        matrix = csr_matrix(
            (data, (rows, cols)), shape=(n_tets * n_edges_per_tet, n_nodes)
        )

        # Apply the matrix
        out = pybamm.Matrix(matrix) @ discretised_symbol

        return out

    def edge_to_node(self, discretised_symbol, method="arithmetic"):
        """
        Convert a discretised symbol evaluated on the cell edges to a discretised symbol
        evaluated on the cell nodes for a 3D tetrahedral mesh.

        Parameters
        ----------
        discretised_symbol : :class:`pybamm.Symbol`
            The discretised symbol evaluated on edges
        method : str, optional
            The method to use for the conversion

        Returns
        -------
        :class:`pybamm.Symbol`
            The discretised symbol evaluated on nodes
        """
        domain = discretised_symbol.domain
        submesh = self.mesh[domain]

        # Use standard implementation for non-3D meshes
        if not isinstance(submesh, pybamm.SubMesh3D):
            return super().edge_to_node(discretised_symbol, method)

        # Get the tetrahedra
        tets = submesh.tetrahedra
        n_tets = len(tets)
        n_nodes = len(submesh.points)

        # For each tetrahedron, we have 6 edges
        # (0,1), (0,2), (0,3), (1,2), (1,3), (2,3)
        edge_pairs = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
        n_edges_per_tet = len(edge_pairs)

        rows, cols, data = [], [], []

        node_to_edges = [[] for _ in range(n_nodes)]
        for i, tet in enumerate(tets):
            for j, (e1, e2) in enumerate(edge_pairs):
                node1 = tet[e1]
                node2 = tet[e2]
                edge_idx = i * n_edges_per_tet + j
                node_to_edges[node1].append(edge_idx)
                node_to_edges[node2].append(edge_idx)

        for i, edges in enumerate(node_to_edges):
            if edges:
                for edge_idx in edges:
                    rows.append(i)
                    cols.append(edge_idx)
                    data.append(1.0 / len(edges))

        matrix = csr_matrix(
            (data, (rows, cols)), shape=(n_nodes, n_tets * n_edges_per_tet)
        )

        out = pybamm.Matrix(matrix) @ discretised_symbol

        return out
